// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go k8s.io/api/storagemigration/v1alpha1

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	corev1 "k8s.io/api/core/v1"
)

// StorageVersionMigration represents a migration of stored data to the latest
// storage version.
#StorageVersionMigration: {
	metav1.#TypeMeta

	// Standard object metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Specification of the migration.
	// +optional
	spec?: #StorageVersionMigrationSpec @go(Spec) @protobuf(2,bytes,opt)

	// Status of the migration.
	// +optional
	status?: #StorageVersionMigrationStatus @go(Status) @protobuf(3,bytes,opt)
}

// Spec of the storage version migration.
#StorageVersionMigrationSpec: {
	// The resource that is being migrated. The migrator sends requests to
	// the endpoint serving the resource.
	// Immutable.
	resource: #GroupVersionResource @go(Resource) @protobuf(1,bytes,opt)

	// The token used in the list options to get the next chunk of objects
	// to migrate. When the .status.conditions indicates the migration is
	// "Running", users can use this token to check the progress of the
	// migration.
	// +optional
	continueToken?: string @go(ContinueToken) @protobuf(2,bytes,opt)
}

// The names of the group, the version, and the resource.
#GroupVersionResource: {
	// The name of the group.
	group?: string @go(Group) @protobuf(1,bytes,opt)

	// The name of the version.
	version?: string @go(Version) @protobuf(2,bytes,opt)

	// The name of the resource.
	resource?: string @go(Resource) @protobuf(3,bytes,opt)
}

#MigrationConditionType: string // #enumMigrationConditionType

#enumMigrationConditionType:
	#MigrationRunning |
	#MigrationSucceeded |
	#MigrationFailed

// Indicates that the migration is running.
#MigrationRunning: #MigrationConditionType & "Running"

// Indicates that the migration has completed successfully.
#MigrationSucceeded: #MigrationConditionType & "Succeeded"

// Indicates that the migration has failed.
#MigrationFailed: #MigrationConditionType & "Failed"

// Describes the state of a migration at a certain point.
#MigrationCondition: {
	// Type of the condition.
	type: #MigrationConditionType @go(Type) @protobuf(1,bytes,opt,casttype=MigrationConditionType)

	// Status of the condition, one of True, False, Unknown.
	status: corev1.#ConditionStatus @go(Status) @protobuf(2,bytes,opt,casttype=k8s.io/api/core/v1.ConditionStatus)

	// The last time this condition was updated.
	// +optional
	lastUpdateTime?: metav1.#Time @go(LastUpdateTime) @protobuf(3,bytes,opt)

	// The reason for the condition's last transition.
	// +optional
	reason?: string @go(Reason) @protobuf(4,bytes,opt)

	// A human readable message indicating details about the transition.
	// +optional
	message?: string @go(Message) @protobuf(5,bytes,opt)
}

// Status of the storage version migration.
#StorageVersionMigrationStatus: {
	// The latest available observations of the migration's current state.
	// +patchMergeKey=type
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=type
	// +optional
	conditions?: [...#MigrationCondition] @go(Conditions,[]MigrationCondition) @protobuf(1,bytes,rep)

	// ResourceVersion to compare with the GC cache for performing the migration.
	// This is the current resource version of given group, version and resource when
	// kube-controller-manager first observes this StorageVersionMigration resource.
	resourceVersion?: string @go(ResourceVersion) @protobuf(2,bytes,opt)
}

// StorageVersionMigrationList is a collection of storage version migrations.
#StorageVersionMigrationList: {
	metav1.#TypeMeta

	// Standard list metadata
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	metadata?: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// Items is the list of StorageVersionMigration
	// +patchMergeKey=type
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=type
	items: [...#StorageVersionMigration] @go(Items,[]StorageVersionMigration) @protobuf(2,bytes,rep)
}
